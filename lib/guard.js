// Generated by CoffeeScript 1.6.3
(function() {
  var EventEmitter, MemoryStore, fresh, guard, prop, val, _ref,
    __slice = [].slice;

  EventEmitter = require('events').EventEmitter;

  fresh = require('fresh');

  MemoryStore = require('./memory_store');

  guard = function() {
    var invalidators;
    invalidators = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return function(req, res, next) {
      if (req.method !== 'GET') {
        return next();
      }
      return guard.store.get(req.url, function(err, cached) {
        var end;
        if (err != null) {
          return next(err);
        }
        if (fresh(req.headers, (cached != null ? cached.headers : void 0) || {})) {
          guard.emit('hit', req.url, cached);
          res.set(cached.headers);
          res.set('X-Connect-Guard', 'hit');
          return res.send(304);
        }
        guard.emit('miss', req.url, cached);
        res.set('X-Connect-Guard', 'miss');
        res.cacheable = function(_arg) {
          var etag, lastModified, _ref;
          _ref = _arg != null ? _arg : {}, lastModified = _ref.lastModified, etag = _ref.etag;
          if (lastModified != null) {
            this.set('Last-Modified', new Date(lastModified).toUTCString());
          }
          if (etag != null) {
            return this.set('Etag', etag);
          }
        };
        end = res.end;
        res.end = function() {
          var headers, name, _i, _len, _ref;
          end.apply(res, arguments);
          if (!((this.statusCode >= 200 && this.statusCode < 300) || 304 === this.statusCode)) {
            return;
          }
          headers = {};
          _ref = ['expires', 'last-modified', 'etag', 'cache-control'];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            name = _ref[_i];
            if (this._headers[name] != null) {
              headers[name] = this._headers[name];
            }
          }
          if (Object.keys(headers).length) {
            return guard.store.set(req.url, {
              createdAt: new Date(),
              headers: headers
            }, function(err) {
              var invalidator, _j, _len1, _results;
              if (err != null) {
                return guard.emit('error', "Error storing headers for path '" + req.url + "'", err);
              }
              guard.emit('add', req.url, headers);
              _results = [];
              for (_j = 0, _len1 = invalidators.length; _j < _len1; _j++) {
                invalidator = invalidators[_j];
                _results.push(invalidator.once('stale', function() {
                  return guard.invalidate(req.url);
                }));
              }
              return _results;
            });
          }
        };
        return next();
      });
    };
  };

  guard.invalidate = function(path, callback) {
    var _this = this;
    return this.store["delete"](path, function(err, cached) {
      _this.emit('invalidate', path, cached);
      if (callback != null) {
        return callback(err, cached);
      }
    });
  };

  guard.MemoryStore = MemoryStore;

  guard.store = new MemoryStore();

  _ref = EventEmitter.prototype;
  for (prop in _ref) {
    val = _ref[prop];
    guard[prop] = val;
  }

  guard.setMaxListeners(0);

  module.exports = guard;

}).call(this);
