// Generated by CoffeeScript 1.9.2
(function() {
  var EventEmitter, Guard, MemoryStore, fresh, guard,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  EventEmitter = require('events').EventEmitter;

  fresh = require('fresh');

  MemoryStore = require('./memory_store');

  Guard = (function(superClass) {
    extend(Guard, superClass);

    function Guard(arg) {
      var store;
      store = (arg != null ? arg : {}).store;
      this.middleware = bind(this.middleware, this);
      this.configure({
        store: store || new MemoryStore()
      });
      this.setMaxListeners(0);
    }

    Guard.prototype.configure = function(arg) {
      var store;
      store = (arg != null ? arg : {}).store;
      if (store != null) {
        this.store = store;
      }
      return this;
    };

    Guard.prototype.invalidate = function(key, callback) {
      if (key instanceof RegExp || typeof key === 'string') {
        key = {
          url: key,
          headers: {}
        };
      }
      return this.store["delete"](key, (function(_this) {
        return function(err, cached) {
          _this.emit('invalidate', key, cached);
          if (callback != null) {
            return callback(err, cached);
          }
        };
      })(this));
    };

    Guard.prototype.parseCacheControl = function(str) {
      var directive, directives, i, key, len, obj, parts, val;
      directives = str.split(',');
      obj = {};
      for (i = 0, len = directives.length; i < len; i++) {
        directive = directives[i];
        parts = directive.split('=');
        key = parts.shift().trim();
        val = parseInt(parts.shift(), 10);
        obj[key] = isNaN(val) ? true : val;
      }
      return obj;
    };

    Guard.prototype.expired = function(cacheEntry, ttl) {
      var cacheControl, expiresAt, maxAge;
      if (ttl >= 0) {
        expiresAt = cacheEntry.createdAt.valueOf() + ttl * 1000;
        return expiresAt < Date.now();
      }
      if (cacheEntry.headers['Cache-Control'] == null) {
        return false;
      }
      cacheControl = this.parseCacheControl(cacheEntry.headers['Cache-Control']);
      if ((maxAge = cacheControl['max-age']) == null) {
        return false;
      }
      expiresAt = cacheEntry.createdAt.valueOf() + maxAge * 1000;
      return expiresAt < Date.now();
    };

    Guard.prototype.fresh = function(requestHeaders, cachedHeaders) {
      var cached, key, value;
      cached = {};
      for (key in cachedHeaders) {
        value = cachedHeaders[key];
        cached[key.toLowerCase()] = value;
      }
      return fresh(requestHeaders, cached);
    };

    Guard.prototype.key = function(req, res) {
      var header, i, key, len, ref, ref1;
      key = {
        url: req.originalUrl || req.url,
        headers: {}
      };
      ref1 = ((ref = res.get('Vary')) != null ? ref.split(/, */) : void 0) || [];
      for (i = 0, len = ref1.length; i < len; i++) {
        header = ref1[i];
        key.headers[header.toLowerCase()] = req.get(header);
      }
      return key;
    };

    Guard.prototype.middleware = function(options) {
      var guard, ttl;
      if (options == null) {
        options = {};
      }
      ttl = options.ttl || options.maxAge || -1;
      guard = this;
      return function(req, res, next) {
        var key;
        if (req.method !== 'GET') {
          return next();
        }
        res.cacheable = function(arg) {
          var etag, lastModified, maxAge, ref;
          ref = arg != null ? arg : {}, lastModified = ref.lastModified, etag = ref.etag, maxAge = ref.maxAge;
          if (lastModified != null) {
            this.set('Last-Modified', new Date(lastModified).toUTCString());
          }
          if (etag != null) {
            this.set('Etag', etag);
          }
          if (maxAge != null) {
            this.set('Cache-Control', "public, max-age=" + maxAge + ", must-revalidate");
          }
          return delete this._headers['set-cookie'];
        };
        key = guard.key(req, res);
        return guard.store.get(key, function(err, cached) {
          var expressAddedEtag, i, len, name, ref, send;
          if (err != null) {
            return next(err);
          }
          if ((cached != null) && guard.expired(cached, ttl)) {
            ref = ['if-modified', 'if-none-match'];
            for (i = 0, len = ref.length; i < len; i++) {
              name = ref[i];
              delete req.headers[name];
            }
            guard.invalidate(key, function(err) {
              if (err != null) {
                return guard.emit('error', "Error expiring headers for '" + (JSON.stringify(key)) + "'", err);
              }
            });
          } else if ((cached != null) && guard.fresh(req.headers, cached.headers)) {
            guard.emit('hit', key, cached);
            res.set(cached.headers);
            res.set('X-Connect-Guard', 'hit');
            return res.send(304);
          }
          guard.emit('miss', key, cached);
          res.set('X-Connect-Guard', 'miss');
          if (options.maxAge != null) {
            res.cacheable({
              maxAge: options.maxAge
            });
          }
          expressAddedEtag = false;
          send = res.send;
          res.send = function() {
            var etagBeforeSend;
            etagBeforeSend = this.get('Etag');
            send.apply(res, arguments);
            return expressAddedEtag = this.get('Etag') !== etagBeforeSend;
          };
          res.on('header', function() {
            var headers, j, len1, ref1;
            if (!((this.statusCode >= 200 && this.statusCode < 300) || 304 === this.statusCode)) {
              return;
            }
            if (!((this.get('Last-Modified') != null) || ((this.get('Etag') != null) && expressAddedEtag))) {
              this.cacheable({
                lastModified: (cached != null ? cached.headers['Last-Modified'] : void 0) || Date.now()
              });
            } else {
              this.cacheable();
            }
            headers = {};
            ref1 = ['Last-Modified', 'Etag', 'Cache-Control'];
            for (j = 0, len1 = ref1.length; j < len1; j++) {
              name = ref1[j];
              if (this.get(name) != null) {
                headers[name] = this.get(name);
              }
            }
            if (Object.keys(headers).length) {
              return guard.store.set(key, {
                createdAt: Date.now(),
                headers: headers
              }, function(err) {
                if (err != null) {
                  return guard.emit('error', "Error storing headers for '" + (JSON.stringify(key)) + "'", err);
                }
                return guard.emit('add', key, headers);
              });
            }
          });
          return next();
        });
      };
    };

    return Guard;

  })(EventEmitter);

  module.exports = guard = new Guard({
    store: new MemoryStore()
  });

  guard.Guard = Guard;

  guard.MemoryStore = MemoryStore;

}).call(this);
