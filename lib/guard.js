// Generated by CoffeeScript 1.6.3
(function() {
  var EventEmitter, Guard, MemoryStore, fresh, guard, instance, parseCacheControl,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  EventEmitter = require('events').EventEmitter;

  fresh = require('fresh');

  parseCacheControl = require('connect/lib/utils').parseCacheControl;

  MemoryStore = require('./memory_store');

  Guard = (function(_super) {
    __extends(Guard, _super);

    function Guard(_arg) {
      this.store = _arg.store;
      this.middleware = __bind(this.middleware, this);
      if (this.store == null) {
        this.store = new MemoryStore();
      }
      this.setMaxListeners(0);
    }

    Guard.prototype.invalidate = function(path, callback) {
      var _this = this;
      return this.store["delete"](path, function(err, cached) {
        _this.emit('invalidate', path, cached);
        if (callback != null) {
          return callback(err, cached);
        }
      });
    };

    Guard.prototype.expired = function(res) {
      var cacheControl, expiresAt, maxAge;
      if ((res != null ? res.headers['cache-control'] : void 0) == null) {
        return false;
      }
      cacheControl = parseCacheControl(res != null ? res.headers['cache-control'] : void 0);
      if ((maxAge = cacheControl['max-age']) == null) {
        return false;
      }
      expiresAt = res.createdAt.valueOf() + maxAge * 1000;
      return expiresAt < Date.now();
    };

    Guard.prototype.middleware = function() {
      var guard, invalidators;
      invalidators = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      guard = this;
      return function(req, res, next) {
        if (req.method !== 'GET') {
          return next();
        }
        return guard.store.get(req.url, function(err, cached) {
          var end, name, _i, _len, _ref;
          if (err != null) {
            return next(err);
          }
          if ((cached != null) && guard.expired(cached)) {
            _ref = ['if-modified', 'if-none-match'];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              name = _ref[_i];
              delete req.headers[name];
            }
            guard.invalidate(req.url, function(err) {
              if (err != null) {
                return guard.emit('error', "Error expiring headers for path '" + req.url + "'", err);
              }
            });
          } else if (fresh(req.headers, (cached != null ? cached.headers : void 0) || {})) {
            guard.emit('hit', req.url, cached);
            res.set(cached.headers);
            res.set('X-Connect-Guard', 'hit');
            return res.send(304);
          }
          guard.emit('miss', req.url, cached);
          res.set('X-Connect-Guard', 'miss');
          res.cacheable = function(_arg) {
            var etag, lastModified, maxAge, _ref1;
            _ref1 = _arg != null ? _arg : {}, lastModified = _ref1.lastModified, etag = _ref1.etag, maxAge = _ref1.maxAge;
            if (lastModified != null) {
              this.set('Last-Modified', new Date(lastModified).toUTCString());
            }
            if (etag != null) {
              this.set('Etag', etag);
            }
            if (maxAge != null) {
              this.set('Cache-Control', "public, max-age=" + maxAge + ", must-revalidate");
            }
            return delete this._headers['set-cookie'];
          };
          end = res.end;
          res.end = function() {
            var headers, _j, _len1, _ref1;
            end.apply(res, arguments);
            if (!((this.statusCode >= 200 && this.statusCode < 300) || 304 === this.statusCode)) {
              return;
            }
            headers = {};
            _ref1 = ['expires', 'last-modified', 'etag', 'cache-control'];
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              name = _ref1[_j];
              if (this._headers[name] != null) {
                headers[name] = this._headers[name];
              }
            }
            if (Object.keys(headers).length) {
              return guard.store.set(req.url, {
                createdAt: new Date(),
                headers: headers
              }, function(err) {
                var invalidator, _k, _len2, _results;
                if (err != null) {
                  return guard.emit('error', "Error storing headers for path '" + req.url + "'", err);
                }
                guard.emit('add', req.url, headers);
                _results = [];
                for (_k = 0, _len2 = invalidators.length; _k < _len2; _k++) {
                  invalidator = invalidators[_k];
                  if (typeof invalidator === 'function') {
                    invalidator = invalidator(req);
                  }
                  _results.push(invalidator.once('stale', function() {
                    return guard.invalidate(req.url);
                  }));
                }
                return _results;
              });
            }
          };
          return next();
        });
      };
    };

    return Guard;

  })(EventEmitter);

  instance = new Guard({
    store: new MemoryStore()
  });

  module.exports = guard = instance.middleware;

  guard.instance = instance;

  guard.Guard = Guard;

  guard.MemoryStore = MemoryStore;

}).call(this);
