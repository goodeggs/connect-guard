// Generated by CoffeeScript 1.6.3
(function() {
  var EventEmitter, Guard, MemoryStore, fresh, guard, parseCacheControl,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  EventEmitter = require('events').EventEmitter;

  fresh = require('fresh');

  parseCacheControl = require('connect/lib/utils').parseCacheControl;

  MemoryStore = require('./memory_store');

  Guard = (function(_super) {
    __extends(Guard, _super);

    function Guard(_arg) {
      var store;
      store = (_arg != null ? _arg : {}).store;
      this.middleware = __bind(this.middleware, this);
      this.configure({
        store: store || new MemoryStore()
      });
      this.setMaxListeners(0);
    }

    Guard.prototype.configure = function(_arg) {
      var store;
      store = (_arg != null ? _arg : {}).store;
      if (store != null) {
        this.store = store;
      }
      return this;
    };

    Guard.prototype.invalidate = function(path, callback) {
      var _this = this;
      return this.store["delete"](path, function(err, cached) {
        _this.emit('invalidate', path, cached);
        if (callback != null) {
          return callback(err, cached);
        }
      });
    };

    Guard.prototype.expired = function(cacheEntry, ttl) {
      var cacheControl, expiresAt, maxAge;
      if (ttl >= 0) {
        expiresAt = cacheEntry.createdAt.valueOf() + ttl * 1000;
        return expiresAt < Date.now();
      }
      if (cacheEntry.headers['Cache-Control'] == null) {
        return false;
      }
      cacheControl = parseCacheControl(cacheEntry.headers['Cache-Control']);
      if ((maxAge = cacheControl['max-age']) == null) {
        return false;
      }
      expiresAt = cacheEntry.createdAt.valueOf() + maxAge * 1000;
      return expiresAt < Date.now();
    };

    Guard.prototype.fresh = function(requestHeaders, cachedHeaders) {
      var cached, key, value;
      cached = {};
      for (key in cachedHeaders) {
        value = cachedHeaders[key];
        cached[key.toLowerCase()] = value;
      }
      return fresh(requestHeaders, cached);
    };

    Guard.prototype.middleware = function(options) {
      var guard, ttl;
      if (options == null) {
        options = {};
      }
      ttl = options.ttl || options.maxAge || -1;
      guard = this;
      return function(req, res, next) {
        var url;
        if (req.method !== 'GET') {
          return next();
        }
        res.cacheable = function(_arg) {
          var etag, lastModified, maxAge, _ref;
          _ref = _arg != null ? _arg : {}, lastModified = _ref.lastModified, etag = _ref.etag, maxAge = _ref.maxAge;
          if (lastModified != null) {
            this.set('Last-Modified', new Date(lastModified).toUTCString());
          }
          if (etag != null) {
            this.set('Etag', etag);
          }
          if (maxAge != null) {
            this.set('Cache-Control', "public, max-age=" + maxAge + ", must-revalidate");
          }
          return delete this._headers['set-cookie'];
        };
        url = req.originalUrl || req.url;
        return guard.store.get(url, function(err, cached) {
          var end, expressAddedEtag, name, send, _i, _len, _ref;
          if (err != null) {
            return next(err);
          }
          if ((cached != null) && guard.expired(cached, ttl)) {
            _ref = ['if-modified', 'if-none-match'];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              name = _ref[_i];
              delete req.headers[name];
            }
            guard.invalidate(url, function(err) {
              if (err != null) {
                return guard.emit('error', "Error expiring headers for path '" + url + "'", err);
              }
            });
          } else if ((cached != null) && guard.fresh(req.headers, cached.headers)) {
            guard.emit('hit', url, cached);
            res.set(cached.headers);
            res.set('X-Connect-Guard', 'hit');
            return res.send(304);
          }
          guard.emit('miss', url, cached);
          res.set('X-Connect-Guard', 'miss');
          if (options.maxAge != null) {
            res.cacheable({
              maxAge: options.maxAge
            });
          }
          expressAddedEtag = false;
          send = res.send;
          res.send = function() {
            var etagBeforeSend;
            etagBeforeSend = this.get('Etag');
            send.apply(res, arguments);
            return expressAddedEtag = this.get('Etag') !== etagBeforeSend;
          };
          end = res.end;
          res.end = function() {
            var headers, _j, _len1, _ref1;
            if (!((this.statusCode >= 200 && this.statusCode < 300) || 304 === this.statusCode)) {
              return end.apply(res, arguments);
            }
            if (!((this.get('Last-Modified') != null) || ((this.get('Etag') != null) && expressAddedEtag))) {
              this.cacheable({
                lastModified: (cached != null ? cached.headers['Last-Modified'] : void 0) || Date.now()
              });
            }
            end.apply(res, arguments);
            headers = {};
            _ref1 = ['Last-Modified', 'Etag', 'Cache-Control'];
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              name = _ref1[_j];
              if (this.get(name) != null) {
                headers[name] = this.get(name);
              }
            }
            if (Object.keys(headers).length) {
              return guard.store.set(url, {
                createdAt: new Date(),
                headers: headers
              }, function(err) {
                if (err != null) {
                  return guard.emit('error', "Error storing headers for path '" + url + "'", err);
                }
                return guard.emit('add', url, headers);
              });
            }
          };
          return next();
        });
      };
    };

    return Guard;

  })(EventEmitter);

  module.exports = guard = new Guard({
    store: new MemoryStore()
  });

  guard.Guard = Guard;

  guard.MemoryStore = MemoryStore;

}).call(this);
